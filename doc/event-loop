Current event loop is a big mess and is begging for a rewrite.

The plan is to ignore this need until after 0.1 is out.  I feel that the 
plugin API will be clean enough to survive the rewirte and only the wmii.lua
internals will be effected.

== Why this is even here

The problem is that the libixp interface does not permit a select() loop to
be ran against the ixp socket w/o a major rewrite of the ixp library.  I
am not interested in this.

== Story for 0.1

The solution taken for 0.1 was to use alarm() to interrupt the blocking ixp
library read call and call a lua function from the signal handler.  This
ends up being problematic because it's not possible to call into libixp
from this state.  For each timer we have to fork off a wmiir process to
inject an event that eventally causes the /event reader to unblock and
return the event and permit for the timers to run.

== Proposed solution

The cleanest way to handle multiple event sources is via a select() or
poll() loop.  However the blocking nature of libixp is still a problem.
Fortunately, there is only one file in wmii's ixp filesystem that
would cause blocking... the /event file.  This is a magic file that
never stops generating content; at least not while wmii is running.

To handle IO on all wmii files we will use the libixp.so library.  It's
already good at what it does... accessing readily available content.
For handling the read of the /event file we will fork off a wmiir
process to read it.  This process will be connected to the main program
via an anonymous fifo.  One side of the fifo will be fed by wmiir, and
the other will be used on the lua side in a select() loop.

The select loop will be implemented in C.  There will be a new library
implementing the eventloop module.  wmii.lua will create an eventloop
and add a wmiir process to it via an api call.  It will then call a
run_loop() function with a duration which will cause the select loop to
run for that much time.  On return from the run_loop() function,
wmii.lua will execute the next timer that's queued up.

Here is what it will look like:

        el = eventloop.new()
        el.add_exec ("wmiir read /events",
                        function (line)
                                ... process event ...
                        end)
        ...
        while true do
                local next_timer = handle_timers()
                el.run_loop(next_timer)
        end

The nice thing about this is that plugins can use this to generate
output on the bar:

        widget = wmii.widget:new ("990_load")
        el.add_exec ("dstat --load --nocolor --noheaders --noupdate",
                        function (line)
                                widget:sow (line)
                        end)

This will make it really clean to get events from other sources.  We can
fork off netcat or tail to get other events.  Best of all no threads or
alarm hacks.

And the ASCII diagram looks like this.

    (1)                (3)                      (4)
  +------+  (ixp) +--------+   read/write() +------------+
  | wmii | <----- | ixp.so | <------------- | wmiirc.lua |
  +------+        +--------+                +------------+
        ^                                         |
        |                                         v 
        | (ixp)       (6)                  +--------------+
     +-------------------+     (fifo)      | eventloop.so | (5)
     | wmiir read /event | --------------> |   select()   |
     +-------------------+                 +--------------+
                                                  |
                                                  | (fifo)
                                                  v
                                           +-------------+
                                           |  other data | (7)
                                           |   sources   |
                                           +-------------+



vim: set ts=8 et sw=8 tw=72
