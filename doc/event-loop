== About

The problem is that the libixp interface does not permit a select() loop to
be ran against the ixp socket w/o a major rewrite of the ixp library.  I
am not interested in this.

== The eventloop library

The cleanest way to handle multiple event sources is via a select() or
poll() loop.  However the blocking nature of libixp is still a problem.
Fortunately, there is only one file in wmii's ixp filesystem that would
cause blocking... the /event file.  This is a magic file that never
stops generating content; at least not while wmii is running.

To handle IO on all wmii files we use the libixp.so library.  It's
already good at what it does... accessing readily available content.
For handling the read of the /event file we fork off a wmiir process to
read it.  This process is connected to the main program via a pipe(2).
One side of the pipe is fed by wmiir, and the other is used on the lua
side in a select() loop.

The select loop is implemented in C, and exported to lua as an eventloop
module.  wmii.lua creates an eventloop instance and adds a wmiir process
to it via an api call.  It then calls a run_loop() function with a
duration which causes the select loop to run for that much time, or less
if data is generated by the wmiir process.  On return from the
run_loop() function, wmii.lua executes the next timer that's queued up.

Here is what it looks like:

        el = eventloop.new()
        el.add_exec ("wmiir read /events",
                        function (line)
                                ... process event ...
                        end)
        ...
        while true do
                local next_timer = handle_timers()
                el.run_loop(next_timer)
        end

The nice thing about this is that plugins can use this to generate
output on the bar:

        widget = wmii.widget:new ("990_load")
        el.add_exec ("dstat --load --nocolor --noheaders --noupdate",
                        function (line)
                                widget:show (line)
                        end)

This makes it really clean to get events from other sources.  We can
fork off netcat or tail to get other events.  Best of all no threads or
alarm hacks.

And the ASCII diagram looks like this.

    (1)                (3)                      (4)
  +------+  (ixp) +--------+   read/write() +------------+
  | wmii | <----- | ixp.so | <------------- | wmiirc.lua |
  +------+        +--------+                +------------+
        ^                                         |
        |                                         v 
        | (ixp)       (6)                  +--------------+
     +-------------------+     (fifo)      | eventloop.so | (5)
     | wmiir read /event | --------------> |   select()   |
     +-------------------+                 +--------------+
                                                  |
                                                  | (fifo)
                                                  v
                                           +-------------+
                                           |  other data | (7)
                                           |   sources   |
                                           +-------------+



vim: set ts=8 et sw=8 tw=72
